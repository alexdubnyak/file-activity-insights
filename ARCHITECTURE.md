# Архитектура проекта File Activity Insights

## Обзор архитектуры

File Activity Insights построен на современной React архитектуре с использованием функциональных компонентов и хуков. Проект следует принципам модульности, переиспользования кода и разделения ответственности.

## Структура компонентов

### Иерархия компонентов

```
App
├── Header
│   ├── SearchBar
│   ├── ProfileMenu
│   └── HelpMenu
├── Sidebar
│   └── RecentFilesToggle
└── MainContent
    ├── RecentFilesList
    ├── ToolBarRow
    ├── Breadcrumbs
    └── FileBrowser
        ├── TitleRow
        ├── FileBrowserRow (множественные)
        └── BrowserMenu (контекстное меню)
```

### Основные принципы

1. **Компонентная архитектура** - каждый UI элемент выделен в отдельный компонент
2. **Единственный источник истины** - состояние управляется в родительских компонентах
3. **Пропсы как контракт** - четко определенные интерфейсы между компонентами
4. **Обработчики событий** - централизованная обработка пользовательских действий

## Управление состоянием

### Локальное состояние
- Используется `useState` для простых состояний компонентов
- Состояние поднимается до ближайшего общего родителя при необходимости

### Основные состояния
- `recentFilesEnabled` - отображение блока недавних файлов
- Состояния меню (открыто/закрыто)
- Состояния форм и модальных окон

## Обработка событий

### Паттерн обработки событий
```javascript
// В родительском компоненте (App.jsx)
const handleFileClick = (file) => {
  console.log('File clicked:', file);
  // Логика обработки клика по файлу
};

// Передача в дочерний компонент
<FileBrowser onFileClick={handleFileClick} />
```

### Типы событий
- **Навигационные события** - клики по хлебным крошкам, папкам
- **Файловые операции** - создание, удаление, переименование
- **UI события** - открытие/закрытие меню, переключение режимов

## Стилизация

### CSS архитектура
- **Модульные стили** - каждый компонент имеет свой CSS файл
- **BEM методология** - для именования классов
- **CSS переменные** - для цветовой схемы и размеров
- **Адаптивность** - медиа-запросы для различных экранов

### Цветовая схема
```css
:root {
  --bg-primary: #111827;
  --bg-secondary: #ffffff;
  --text-primary: #000000;
  --text-secondary: #666666;
  --accent-color: #007bff;
}
```

## Система иконок

### SVG иконки
- Все иконки хранятся как React компоненты
- Масштабируемые и настраиваемые
- Оптимизированы для производительности

### Организация иконок
```
src/assets/
├── breadcrumbs/
├── file-browser/
├── header/
└── [другие категории]
```

## Доступность (A11y)

### Реализованные возможности
- **ARIA атрибуты** - для скрин-ридеров
- **Клавиатурная навигация** - Tab, Enter, Escape
- **Семантическая разметка** - правильные HTML теги
- **Контрастность** - соответствие WCAG стандартам

## Производительность

### Оптимизации
- **Lazy loading** - для больших списков файлов
- **Мемоизация** - React.memo для предотвращения лишних рендеров
- **Виртуализация** - для больших объемов данных
- **Оптимизация изображений** - SVG иконки вместо растровых

## Тестирование

### Стратегия тестирования
- **Unit тесты** - для отдельных компонентов
- **Integration тесты** - для взаимодействия компонентов
- **E2E тесты** - для пользовательских сценариев

### Инструменты
- Jest - для unit тестов
- React Testing Library - для тестирования компонентов
- Cypress - для E2E тестирования

## Развертывание

### Сборка проекта
```bash
npm run build
```

### Статические файлы
- Генерируются в папку `dist/`
- Готовы для развертывания на любом статическом хостинге
- Оптимизированы и минифицированы

## Расширяемость

### Добавление новых компонентов
1. Создать компонент в `src/components/`
2. Добавить соответствующие стили
3. Интегрировать в родительский компонент
4. Добавить обработчики событий

### Добавление новых функций
1. Определить требования к состоянию
2. Создать необходимые компоненты
3. Интегрировать с существующей архитектурой
4. Добавить тесты

## Лучшие практики

### Код
- Использование TypeScript для типизации (рекомендуется)
- Консистентное именование компонентов и функций
- Документирование сложных функций
- Следование ESLint правилам

### Компоненты
- Один компонент - одна ответственность
- Переиспользуемые компоненты в отдельных файлах
- Пропсы с дефолтными значениями
- Валидация пропсов (PropTypes или TypeScript)
